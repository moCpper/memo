C++因其媲美C的性能和跨平台特性，被广泛应用于追求高性能的领域，如嵌入式系统、服务器开发、音视频处理、游戏引擎以及量化金融等。

然而，高性能的代价是较低的易用性。毕竟，高风险往往伴随着高回报。

与现代语言如`Go`、`C#`、`Rust`相比，C++的使用门槛更高。正如C++之父本贾尼·斯特劳斯特卢普所言：  
**“软件行业中，太多的管理者试图将编程变成低级别的流水线工作。从长远来看，这种做法效率低下、浪费严重、成本高昂，而且不人性化。在软件开发中，没有放之四海而皆准的模型。我们需要为人们提供发挥才干的空间，并鼓励他们成长。”**

C++的设计初衷正是为了**让开发者能够更加自由灵活地编程，而不受语言本身的限制**。  
本篇文档的编写旨在记录我发现的一些容易踩坑的点，希望能为他人提供参考。

---
### 兼容性问题

C++标准委员会每三年更新一次语言标准，但他们仅负责定义标准，具体的实现由各编译器厂商（如 MSVC、GCC、Clang 等）完成。因此，不同编译器生成的 C++ 代码可能互不兼容。例如，使用 MSVC 编译的 DLL 可能无法被 GCC 编译的代码调用：

```c++
// MSVC 编译的 DLL 导出的函数
__declspec(dllexport) void print_string(const std::string& s);

// GCC 编译的调用方
int main() {
    std::string s = "hello";
    print_string(s); // 可能崩溃！
}
```

上述代码可能崩溃的原因在于，MSVC 实现的 `std::string` 与 GCC/Clang 的实现不同（例如成员变量顺序或其他实现细节），导致 ABI 及内存布局不一致，从而引发崩溃。  
**解决方案：统一工具链以避免此类问题的发生。**

---
### 智能指针的使用

从 C++11 开始，推荐使用 `std::shared_ptr` 或 `std::unique_ptr` 来管理资源，而非直接使用裸指针。这些智能指针基于 RAII（资源获取即初始化）设计思想，通过析构函数自动释放资源，从而有效避免内存泄漏。  
然而，滥用智能指针也可能引发资源泄漏问题。例如：

```c++
// 假设 func 用来执行相关操作并返回一个值
int func();

int main() {
    do_something(func(), std::shared_ptr<A>(new A));  // 潜在的资源泄漏
}
```

上述代码看似合理，但却忽略了**指令重排**的问题。在运行中，一个函数的实参必须先被计算，这个函数才会开始执行。所以在调用 `do_something` 之前，必须执行以下操作：
-  执行 `func()` 并获取返回值。
-  执行表达式 `new A`。
-  调用 `std::shared_ptr<A>` 的构造函数接管表达式 `new A` 返回的指针。

编译器并不保证按照执行顺序生成代码，因此可能会产生如下结果：
1. 执行表达式 `new A`。
2. 执行 `func()` 并获取返回值。
3. 调用 `std::shared_ptr<A>` 的构造函数。

如果 `func()` 在执行过程中产生异常，`new A` 返回的指针将永远不会被 `std::shared_ptr<A>` 的构造函数所接管，从而导致资源泄漏。

使用 `std::make_shared` 可以避免上述问题。它不仅更高效（只分配了一次内存，内存块同时容纳了被管理对象和控制块），还能确保资源管理的安全性：
```c++
int func();

int main() {
    do_something(func(), std::make_shared<A>());  // std::make_unique同理
}
```
> **注意**：`std::make_unique` 从 C++14 开始支持。

也存在`std::make_shared`无法替代的情况，当需要自定义删除器时，`std::make_shared`无法做到：
```cpp
void delete_func(A* ptr);        // 自定义删除器
int main(){
	do_something(func(),std::shared_ptr<A>(new A,delete_func));
}
```
将`std::shared_ptr`放到自己的语句中，以避免上述问题的发生：
```cpp
void delete_func(A* ptr);        // 自定义删除器
int main(){
	std::shared_ptr<A> sptr(new A,delete_func);
	do_something(func(),sptr);
}
```

在使用标准库的类型时难免会考虑线程安全的问题，std::shared_ptr同理，考虑以下代码：
```cpp
struct Base{};
struct Dervied : Base{};
void print(const std::shared_ptr<Base>& p);   // 做一些打印操作

void thr(std::shared_ptr<Base> p){
	std::this_thread::sleep_for(987ms);
	std::shared_ptr<Base> t = p;    // 线程安全，虽然自增引用计数
	{
		static std::mutex m;
		std::lock_guard<std::mutex> lock(m);
		print(t);
	}
	
}
int main(){
	std::shared_ptr<Base> sp = std::make_shared<Derived>();
	std::thread t1{thr,sp},t2{thr,sp},t3{thr,sp};
	sp.reset();       // 释放主线程的use_count

	t1.join();
	t2.join();
	t3.join();
}
```
多个`std::shared_ptr`所管理的是同一份数据，用的是同一个`use_count`，但是各自是不同的对象，当发生多线程中操作`sp`的成员函数而不附加同步时(包括拷贝构造和拷贝赋值)，不会出现数据竞争。
然而，**若多个执行线程访问同一 `shared_ptr` 对象而不同步，且任一线程使用 `shared_ptr` 的非 `const `成员函数，就跟使用STL中的其他类型一样，将会出现数据竞争。** 
>`使用std::atomic<shared_ptr<T>>`能用于避免数据竞争。`
```cpp
std::atomic<std::shared_ptr<T>> atomic_sptr;   // 附加原子操作
```

---
### 多线程
避免使用双重检查锁`（Double-Checked Locking）`
考虑以下用双重检查锁实现的单例：
```cpp
class Singleton {
public:
    // 获取单例实例的静态方法
    static std::shared_ptr<Singleton> getInstance() {
        if (instance == nullptr) {  // 第一次检查（无锁）
            std::lock_guard<std::mutex> lock(mtx);  // 加锁
            if (instance == nullptr) {  // 第二次检查（加锁后）
                 instance.reset(new Singleton());
            }
        }
        return instance;
    }
    void doSomething() {
        std::cout << "Singleton instance is working!" << std::endl;
    }
private:
    Singleton() = default; 
    ~Singleton() = default;
    static std::shared_ptr<Singleton> instance;  
    static std::mutex mtx;  
};

std::shared_ptr<Singleton> Singleton::instance = nullptr;
std::mutex Singleton::mtx;
  
int main() {
    auto instance = Singleton::getInstance();
    instance->doSomething();
    return 0;
}
```
这段代码忽略了一些问题：
- 在`instance = std::make_shared<Singleton>();`的过程中，可能会先分配内存并将指针赋值给`instance`，然后再调用构造，若另一个线程在第一次检查后读取了`instance`，` instance->doSomething();`处则可能会访问一个未完全构造的对象，从而导致未定义的行为`(UB)`。
- `std::shared_ptr`没有做同步操作，在多线程的环境下同时访问可能导致数据竞争,引发未定义的行为。可以使用`std::atomic<std::shared_ptr<T>>`避免此问题。
- 虽然锁内的第二次检查能避免重复初始化，但第一次检查的读取操作（无锁）与写操作（加锁）之间存在数据竞争。

使用标准库的`std::call_once`以实现更安全的单例
```cpp
class Singleton {
public:
    static std::shared_ptr<Singleton> getInstance() {
	    static std::once_flag flag;
	    std::call_once(flag,[](){
		    instance.reset(new Singleton());
	    });
        return instance;
    }
private:
    Singleton() = default; 
    ~Singleton() = default;
    static std::shared_ptr<Singleton> instance;  
};
```
或是使用`Magic Static`
```cpp
static Singleton& getInstance(){
	static Singleton s;
	return s;
}
```

---
### 高性能C++
`CRTP`
在实现多态操作时，首选的方式是使用虚函数。
但虚函数存在的一定的运行时开销，每个包含虚函数的类都会维护一个`虚函数表(vtable)`，其存储了指向虚函数实现的指针。当调用虚函数时，程序需要通过对象的虚函数表指针查找对应的函数地址，这增加了一次间接寻址操作，相比普通的函数调用略慢。
且编译器无法对虚函数调用进行**编译期内联优化**，正如如上所说，虚函数调用在运行时根据对象的实际类型决定。
避免以上额外不必要的性能开销的手段之一就是采用`CRTP(奇异递归模板模式)`实现编译期多态。
`CRTP`实现大致如下:
```cpp
template<typename Dervied>
class Base{
public:
	void print(){
		static_case<Dervied*>(this)->print();
	}
};

class Dervied : Base<Dervied>{
public:
	void print(){
		std::cout << " Dervied1::print() " <<std::endl;
	}	
};
```
`CRTP`减少了额外的运行时开销，正因为他是基于模版的多态，函数调用在编译期就确定，不存在虚函数表和动态绑定，编译器也可以直接在编译期进行内联展开，从而提高性能。
`CRTP`多态使用：
```cpp
template<T>
void func(Base<T>& base){
	base.print();
}

int main(){
	Dervied d;
	func(d);         // 输出 Dervied1::print()
}
```

---
### 参考资料
- 《C++并发编程实战(第二版)》
- 《Effective Modern C++》
- 《C++ Core Guidelines》
-    [C++ 参考手册 - cppreference.com](https://zh.cppreference.com/w/cpp)
